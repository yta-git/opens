# 脆弱性・マルウェア解析トラック
設問ひとつあたり4,096文字以内で答えてください。
また正解がある設問については、"正解しているかどうか"より
"正解にたどり着くまでのプロセスや熱意"を重要視しています。
答えにたどり着くまでの試行錯誤や自分なりの工夫等を書いて、精一杯アピールしてください。

## 問1
あなたが今まで作ってきたソフトウェアにはどのようなものがありますか？
また、それらはどんな言語やライブラリを使って作ったのか、
どこにこだわって作ったのか、たくさん自慢してください。

私は，思いついたアイデアを短時間で作ることが多いです．
ここ最近では，以下のようなものを作りました．

## レーザーポインタを用いた家電操作システム

主に使用したもの: Python3 + OpenCV, Arduino(の互換機)

NICT主催のSechack365で開発しました．
このシステムを利用すれば，リモコンや，スマートスピーカ，タブレットに変わってレーザーポインタを用いて家電や情報を操作することができるようになります．

コンピュータに繋いだウェブカメラから，レーザーがどこを指しているのかや，レーザーがどのように動いているのかを認識し，
得られたデータをもとに，家電へ命令を送ります．

このシステムを使う利点は大きく以下の点です．
1. たくさんの家電を一つのレーザーにまとめることができる．
2. 声を出さないので，病院，映画館，講義・発表中でも使用することができる．
3. 言葉にしにくい「あの辺」や「それ」を機械に伝えることができる．
4. 目に見える範囲で命令を送ることができる

こだわった点:
1. セキュリティ
このシステムでは，窓の外からレーザーを照射することで家電を不正に操作できることや，レーザー光線が目に入り，怪我をしてしまう可能性が問題になります．私はこれらの問題を，PCとの間で光線の出力情報と，出力しても安全かどうかの情報を通信して，光線の出力を制御することができるレーザーポインタ本体を自作しました．
自作したレーザポインタには，小型のArduino(の互換機)と，Bluetooth通信用モジュール，電池Box(100均製),レーザー光源などが入っており，外部ケースは，自分で3Dモデルを作成し，3Dプリンタにより出力したものを使用しました．

2. レーザーの座標取得の制度をあげる
このシステムでは，光の強さでレーザーポインタの指している位置を計測したので，近くに太陽や，照明など，明るいものがあった場合，レーザーポインタの指している座標を取得できなくなる問題がありました．私は，この問題を，初期設定の段階で，明るいものがどこにあるのかを認識し，
レーザーポインタの座標を計測する際には，明るい場所を画像処理によりフィルタリングをかけて目隠しすることで，取得したいレーザーポインタの座標の精度を上げることができました．

## 人間の手を模したをした情報表現システム&装置「The Hand」

主に使用したもの: Python3, Arduino

大学での発表用に作成しました．
このシステムを利用すると，情報を人間の手を模した装置で表現することができます．

伝えたい情報をPythonに送り，あらかじめ設定しておいたパターンや，プログラムによって，人間の手ではどのように指を動かすのかという情報に変換し，変換された運指情報を手の形をした装置に送信します．情報を受けた「手」に内蔵しているArduinoが運指情報をもとに，手の関節をサーボモータによって動かします．

このシステムを使う利点は以下の点です．
1. 人間にとって馴染みやすい表現(OKサインやピースサインなど)ができる
2. 手話やハンドサインなどでも利用することができる．

こだわった点:

1. 異質感
このシステムを大学での発表用に作成したのですが，先生や友達がみて面白いものを作りたかったので
できるだけ，「可笑しさ」や「無駄さ」を求めました．しかし，実際に作ってみると，手話やハンドサインなどに使うことができるので，以外と実用性があるように思えました．

2. 手の動き
作成した「手」の作りはとても簡単で，100均で購入した軍手に綿を詰めた物を，釣り糸をサーボモータで引っ張ることで実現しています．この「手」の動きをできるだけリアリティのあるものにしたかったので，自分の手を観察し，軍手の中に，少しかたいもの(最終的にはスポンジの硬い部分に落ち着きました)を関節と手の甲の部分に設置し，釣り糸を取り付ける位置や，引っ張る長さなどを微調整しました．

## おかしな文章生成プログラム

主に使用したもの: Python3, MeCab(日本語形態素解析システム), WordNet(日本語の類語関係をまとめたDB)

思いつきで作成しました．
当初は，レポートをコピーしてもバレないようにするために，日本語の表現を変更したり，文章の並びを変更することを目的に開発を始めましたが，実際にはうまくいかず，副産物として，与えられた文章をおかしな文章に変更して出力するプログラムが完成しました．

例として，「セキュリティの問題について考える．」という文を与えると次のような文章が出力されます．
「安全対策の命題について推し測る．」
「安全性の問について惟る．」
「確保の骨の折れることについて思い描く．」
「安全性の障礙について料簡．」
「保障の心配について考案．」
「心強さの障碍について思考．」
「安全策の悩みについて意味．」
「安全性の問題点について思做す．」
「安全保障の問題について検討．」
「安全の筋合いについて決め込む．」

与えられた文章をMeCabで解析することで，単語ごとに文を分解します．
その後，分解された単語にはどのような類語が考えられるのかということを，WordNetのDBに問い合わせます．
得られた類語のリストから，ランダムに単語を選び，文を再構成して出力します．

特に利点は思いつきませんが，機械翻訳によって再翻訳されたような文章が生成できるところが面白いと思います．
また，「この言葉にこんな類語があるのか！」と気がつくことができました．
「元の文章はどのようなものか？」のようなクイズも楽しめると思います．
このプログラムを作成することで，データベースの扱いかたを学ぶことができました．

こだわった点:
1. 簡単に使用できるように
文章の取得 →　解析 →　変換　→ 出力，までの一連の動作を，関数にまとめているので，プログラムの中から利用するときも一行で利用することができます．

1. SQL injection防止
作成したプログラムでは，入力された文字をSQL文に挿入していたので，SQL injectionの脆弱性がありましたが，
適切な関数を選びそれを防ぐことができました．

## 水素濃度計測装置

主に使用したもの: Python + Qt, RaspberryPi

知り合いの名古屋大学の先生と，鈴木商館の人に依頼されて作成しました．
水素濃度計測装置は大きく，「水素濃度を電圧に変換(名古屋大学の研究)」と「得られたアナログの電圧をデジタルに変換，値を計算，結果を表示/保存」の2つの部分に分けることができ，私は後者の開発をしました．

これを利用すれば，液体や気体中に含まれる水素濃度を精度よく，短時間で計測し，結果をその場で表示することができるようになります．

得られた電圧を，ADコンバータに通しデジタルに変換します．
このデジタルの電圧をPythonで処理し，RaspberryPiに搭載した液晶にQtを利用してグラフを描画します．

この作成した装置は，FC EXPO(国際水素・燃料電池展)で展示され，とても良い評価を受けることができました．

こだわった点:
1. 取得する電圧の精度を向上
端子間の電圧を正確に測りたかったのですが，端子やADコンバータなどの抵抗が高く，正確な値を取得することができませんでした．
このことを，電気回路に詳しい親戚に尋ねたところ，「ボルテージフォロア」という回路を使えば解決できることがわかりました．
ボルテージフォロアでは，オペアンプを使うことで，抵抗を0にすることができます．
実際にオペアンプを調達し，ボルテージフォロアの回路を組み込むことで，取得する電圧の制度を向上させることができました．

2. さらなる小型化と低価格化
まだ開発が終わっていないのですが，RaspberryPiでは，商用としては高価で，またサイズも大きいので，現在，ワンチップマイコンで作り直すことを検討しています．

## ブラウザ上で動くカロリー計算支援アプリ

主に使用したもの: JavaScript + enchant.js(ゲームやアプリを開発できるフレームワーク)

大学での発表用に作成しました．
このアプリを使用すれば，ゲーム感覚で食生活を見直し，改善のきっかけを作ることができます．

このアプリのメインの画面では，画面上に描画される食べ物の画像と，目標カロリー値が表示されています．
プレイヤーは，目標カロリーと同じくらいの摂取カロリーになるように，食べ物を組み合わせて選択します．
最後に，プレイヤーが選んだ食品のカロリーと，目標カロリーとの差を評価し，メッセージを表示します．

こだわった点:
1. イラスト
このアプリでは，様々な食べ物のイラストが表示されますが，イラストが小さくて見えにくかったり，
実写の食品では，逆に食欲を増進してしまう問題(通称飯テロ問題)があったので，わかりやすく，また，直接的に食欲を刺激しないラフなイラストを自分で作成しました．
ただ，私の絵心が足りず，友人からは「ピザ」を「バスケットボール」と言われたり，「コーヒーとコーラの見分けがつかない」などと改善案をたくさん受けました．

1. ゲーム性
普通の食生活改善アプリでは，最初から使う気に慣れないと感じ，ゲーム性を強調しました．
具体的には，BGMをポップにしたり，評価する際のメッセージをキャラクターの吹き出しの中に表示させたりしました．

他にも
- 機械学習を用いたゲームAI (Python + Keras)
- 専用ライブラリを使用しない機械学習による画像分類プログラム (Python + Numpy)
- Java標準ライブラリによるシューティングゲーム (Java)
- 自分専用キーボード (Arduino)

など，ソフトウェアとハードウェアの両方の開発をするのが好きです．

## 問2
今までに解析したことのあるソフトウェアやハードウェアにはどのようなものがありますか？また、その解析目的や解析方法、工夫した点があればそれらも教えてください。

「ooのために解析をしよう！」など目的を考えて行ったことはないですが，
小学生の頃から，ものの仕組みや内部の構造に興味があり，これまで様々なものを分解(破壊)してきました．

分解するときには，感電するのが怖いので，電源やバッテリーを外して行います．
また，特殊なねじを回すことが必要になることが多いので，色々な種類のねじを回せるのように，ドライバーのセットを購入しました．
分解の過程がわかるように，写真を取りながら分解を行うことがあります．

### ハードウェア

- HDD
- Nintendo Wii
- Nintendo DSi
- GameBoy Advance SP
- GameBoy Advance SP　のカセット
- ノートPC
- デジタルカメラ
- 一眼レフ
- 液晶ディスプレイ
- 携帯電話
- 扇風機
- デジタル腕時計
- 計算機
- フロッピーディスク
など

大抵の場合，集積回路が入っていて，そんなに面白くない(見た目が大体同じ)なのですが，
たまに面白い部品が出てくるのが分解することのモチベーションになっています．

例えばHDD．初めて分解したのは小学生の時だったと思います．
分解すると，中には，鏡のようにピカピカなディスクと，超強力な磁石が入っています．
この綺麗なディスクを初めて見たときは，すごく感動しました．
何故ならば，このピカピカ加減は，教科書や画面では絶対に表現することはできないもので，実際に開けた人しか見ることができないためです．
また，これを見ると，これが絶対に落としてはいけない超精密機械であると，直感的に理解ができました．

デジタルカメラには，電気を貯めて，一気に放電する部品が入っていました．
私は，これにうっかり素手で触ってしまい，大変びっくりした記憶があります．

フロッピーディスクには，黒色のシートが数枚入っていました．
今考えると，危険だったかもしれませんが，このシートを数枚重ねると，日食グラスのように
太陽の形を見ることのできるフィルタのように機能しました．

また，たまに集積回路に手書きの文字を見つけると，どのような意図で書かれたものなのかを
推測することも面白いです．

最近では，ある会社に会社見学に行った際に，ハードウェアのクラッキングデモを見せていただきました．
攻撃対象は，インターネットが使用できる，ブルーレイプレイヤーだったのですが，設定画面に入力した文字がそのままLinuxのコマンドとして実行されるのは非常に驚きました．
また，この状態で販売までされていたと聞いて，この数年間で情報セキュリティに対する社会の考え方が大きく変化しているんだなと強く感じました．
会社見学に行ってすごく良かったのは，「UART」という言葉を知れたことです．UARTは，デバッグの為に，機器との間で入出力を行うときに使用します．
私は，家に戻ってすぐにAmazonでUARTのUSBの変換ができるモジュールを購入しました．
まだ使用はしていないのですが，近いうちに手元にある電化製品を分解して使用してみたいと思っています．

### ソフトウェア

ソフトウェアは，ほとんど経験がないですが，興味が湧いたり，必要になった時に，
その都度調べて解析を行うことがたまにあります．

よく使うツールは，objdump, strings, ltrace, strace, gdb, radare2などです．

- CTFで少し
- 学校でもらったプログラム
- 自分で作成したプログラ
など

学校でもらったプログラムは，大学の実験の時に受け取ったものですが，
解析して，元がどのようなプログラムであったかを推測してレポートに書いたところ，良い評価をつけてもらいました．

また，自分で書いたC言語がアセンブルされた後には，どのように表現されているのかが気になり，解析したことがあります．
自分で書いたコードと，出力されたアセンブリ言語を順番に対応づけながら読んでいきました．
最初は，全く理解できなかったのですが，アセンブリ言語を学び，最近やっと理解できるようになってきました．

## 問3
Twitterアカウント、Github、ブログ、公開している資料等がありましたら、URL等を記載してください。

今のところありません．個人情報の流出が怖いからです．
ですが，興味はあるので，キャンプに参加することになったら，新しい人脈を維持するためにアカウントを作成するかもしれません．

## 問4
あなたが今年のセキュリティ・キャンプで受講したいと思っている講義は何ですか？（複数可）
またそれらを受講したい理由を教えてください。

受講したいと思っている講義は以下の通りです．

自分が興味のある講義であること，一人で学習するのが難しそうなもの，という観点で選択しました．

## 特別講演（2）「ハッカーは法律を破るのか」
専門①-③ インシデントレスポンスで攻撃者を追いかけろ 
専門④ IN-DEPTH STATIC MALWARE ANALYSIS 
専門⑤ 解析を妨害しよう　～自作パッカー入門～ 
専門⑥ マルウェアの暗号処理を解析しよう
専門⑦ 本当にわかる Spectre と Meltdown
(会員企業のお仕事紹介)

## 特別講演（2）「ハッカーは法律を破るのか」
最近では，インターネット上で様々な脆弱性の情報を見つけることができ．それを自分の環境でも試してみたくなることが多々あります．
また，他人が作ったプログラムや，論文を参考に自分のプログラムを改良してみたくなることもしばしばあります．
しかし，常に私の脳裏には，「今していることは，違法なのではないか？」「これを開発するには免許が必要か？」「このプログラムの著作権は？」
と法律に関することを考えてしまい，現状，情報セキュリティに関する実験は，ほとんど手をつけていませんし，また，やり方も良くわかりません．
そこで，今一度，何が法律で禁止されているのかということや，世の中のエンジニア，ハッカーの人たちはどのように法律を解釈しているのかを
有識者から学び，今後，法律とどのように付き合い，どのように開発，テストをしていくべきなのかを考えたいです．

## 専門①-③ インシデントレスポンスで攻撃者を追いかけろ
私は，アプリケーションを作りたいと思い，色々な言語や，Webサーバなどについて勉強をすることがよくありますが．
作成したアプリケーションをなかなか外部に公開することができていません．
その理由は，アプリケーションを外部に公開した時に，「どのような人がアクセスしてくるのか」，ということや
「もし攻撃を受けた時にどのように対応すれば良いのか」ということが把握できていないためです．
また，自分の作成したアプリケーションには．どのような攻撃を受ける可能性があるのか，という以前に
どんな攻撃が世の中にはあるのかと言うことも正確に把握できていません．
そこで，私はこの講義を受けて，上記のような問題点を技術的な観点から学習し，今後の学習と開発に役立てたいです．

## 専門④ IN-DEPTH STATIC MALWARE ANALYSIS 
## 専門⑤ 解析を妨害しよう　～自作パッカー入門～ 
## 専門⑥ マルウェアの暗号処理を解析しよう
私は以前からマルウェアの解析について興味があったのですが，やはりマルウェアの性質上，
「法的にグレーな部分があること」，また「マルウェアの扱い方に気をつけなければいけない」という観点から，
個人の端末上で解析するのをためらっていました．そこで，今回でセキュリティキャンプに参加して，
「どのようにマルウェアを扱うと安全なのか」，「どのように解析するのか」，また，「どのようにマルウェアを入手するのか」ということを
一気に学び，今後，どのように自分で学習する方法を教えていただきたいです．よろしくお願いします

この時間帯では，他に，「ブラウザ拡張機能の脆弱性を探そう!!」, 「Linuxカーネル脆弱性入門」も選択したかったのですが，
これらの情報はインターネット上に掲載されていた入門者用の解説が，ある程度理解できそうであったので，
今回は，普段触るのが難しそう(なイメージ)であるマルウェアについての講義を選択しました．

## 専門⑦ 本当にわかる Spectre と Meltdown
今現在，大学でコンピュータアーキテクチャ,OS，プロセッサについての講義を受講しています．
それらの講義は大変興味深く，コンピュータの最下層では一体どのように動作しているのかということに興味持たせてくれました．
しかし，この講義で学ぶことができるのは，超基本的，古典的な構造のみであり，
現在，実際に使用されているものとは少し違うものなのではないかと感じています．
また，大学の講義では，「どのような仕組みで動作しているのか」ということしか扱わず，どこに脆弱性があり，どのようにしてそれを防いでいるのか
ということに関しては全く学ぶことができません．
そこで，セキュリティキャンプの「本当にわかる Spectre と Meltdown」の講義では，
現在のCPUはどのような仕組みで動作しているのかということや，どのようにして性能を向上しているのか
また特に，どのような攻撃を受ける可能性があるのかを学べることを期待して応募したいと思いました．

この時間帯では，「IoTのセキュリティを評価できるようにする」も選択したかったのですが，
それ以外の講義でIoTについての講義を選択していなかったので，
IoT技術の技術の部分を学習せずに評価だけ学習するのは少し学習効果が減少してしまうのではないかな？と考えて
選択を見送りました．この部分に関しては，のちに選択を変更する可能性があります．

また講義ではありませんが，「会員企業のお仕事紹介」にも興味があります．
これは，セキュリティには興味があるが，実際の仕事ではどのように技術が使われているのかということが，イマイチ想像がついていないためです．
そこで，私は，お仕事紹介の中で，セキュリティで職を持つならばどのような働き方があるのかを知っておきたかったので，
ここに受講したい理由として書かせていただきました．

## 問5
自分が最も技術的に興味を持った脆弱性をひとつ挙げ、技術的詳細（脆弱性の原因、攻略方法、対策方法など）
について分かったことや思ったこと、調査の過程で工夫したこと等を報告してください。
その際、書籍やウェブサイトを調べて分かったことはその情報源を明記し、
自分が独自に気付いたことや思ったことはそれと分かる形で報告してください。
また脆弱性の攻略方法を試す際は、他者に迷惑を掛けないように万全の措置をとってください。

私がもっとも技術的に興味を持った脆弱性として，
WEPの暗号処理についての脆弱性を挙げる．

WEPの脆弱性に興味があったのですが，そもそもWEPの仕組みを知らなかったので，
先ずは，脆弱性の前に，どのようにして暗号化が機能しているのかを調べました．

### なぜWEPの脆弱性を選んだか
なぜこの時期にWEPなんだ？KRACKsじゃないの？と思うかとは思いますが．WEPの脆弱性を選んだのには理由があります．
なぜWEPの脆弱性を選んだのか．それは，私自身がセキュリティ，および情報科学の世界に興味を持つきっかけになった脆弱性であるからです．

当時，私は小学5年生でしたが，PCの扱いや情報収拾は得意な方でした．ある日，Google検索で遊んでいると，
ハッカージャパンという雑誌のPDFを見つけました，特集されていた内容はWI-FIのパスワードクラックについてでした．
書かれていた記事の通りに，慣れないlinuxを触り，Aircrack-ngなどのコマンド群を入力すると，いとも簡単に自宅のWI-FIのパスワードが判明してしまいました．
しばらくの間は，依頼してきた友達の家のWI-FIを攻撃したりして(ダメですよ)，楽しかったのですが，
次第に，Aircrackのようなプログラムを作ってみたいと思うようになりました．
しかし，当時は，まともに数学の記号の意味もわからず，またどこから手をつけて良いのかわかりませんでした．
そこで，今でも，なんとく覚えているのですが「ハッカー　なり方」などでGoogle検索したところ，Yahoo知恵袋がヒットし，
そこに，C言語を勉強すべしと書かれていたことがきっかけで，C言語を学びはじめました．
これが，私がセキュリティ，および情報科学の世界に興味を持ったきっかけです．

そして大学生になり，プログラミング言語や，ある程度の数学をある程度使えるようになった今，
このセキュリティキャンプの問題を見て，WEPについての学習に再挑戦してみたいと思ったのが
この設問に対して，WEPの脆弱性を選択した理由です．

### WEPとは
従前から無線LANに実装されている暗号方式であり[1]，有線によるネットワークへのアクセスポイントと同等の安全性を実現するために作成されました[2].

### WEPによる暗号化の手法
まず，WEPの暗号化の仕組みを知らなかったので，書籍などを参考に調べまとめました．

WEPによる暗号化は次のように行われます．

1. 平文メッセージMがあります．

[M]

2. 平文メッセージMの整合性を復号時に確認できるように，メッセージMのチェックサムをCRC32関数で計算します．

[CS]

CRC32関数を含むCRCでは，
あらかじめ決めておいた生成多項式で，メッセージを多項式で表現した，情報多項式を除算していった時のあまりを，チェック用の値として利用し，
データの誤りや，破損を検出することができます．
CRC32では生成多項式として，
x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^8 + x^7 + x^6 + x^2 + x + 1
を利用します[3]．

3. 平文メッセージMの末尾に2.で生成したチェックサム付加したものをPとします．

P = [M][CS]

4. 40ビットまたは104ビットのWEPキーを決めます

[WEP]

5. ランダムに生成された初期化ベクタIVをWEPキーの先頭に付加します．これをSとします．

S = [IV][WEP]

6. 5.で得られたSをRC4で変換することで，キーストリームを生成します．

キーストリーム = [RC4(S)]

RC4はSSLやWEPなどで広く使用されているストリーム暗号であり，
次のようなアリゴリズムで暗号化をします[2]．

まず，256個の要素を持つ配列Sに，0から255までの値を順不同で格納します．
次に，256個の要素を持つ配列Kを別に用意し，暗号化の対象の値で埋めます．
暗号化の対象の値が256文字以下であれば，256個の要素全てが埋まるまで，
繰り返し，同じ文字を追加していきます．
その後，次の擬似コードにしたがって配列Sのスクランブルを行います．
j = 0;
for i = 0 to 255{
  j = (j + S[i] + K[i]) mod 256
  S[i] と K[j]を入れ替える;
}

ここまでのアルゴリズムをKSAと言います．

次に，キーストリームを一文字ずつ必要なだけ，次のPRGAというアルゴリズムによって生成します．
(i, j の初期値は0になっています．)

i = (i + 1) mod 256;
j = (j + S[i]) mod 256;
S[i]とS[j]を入れ替える;
t = (S[i] + S[j]) mod 256;
S[t]の値を出力する

出力されたS[t]がキーストリームのバイトになります．

7. 平文メッセージPとキーストリーム[PC4(S)]の排他的論理和を取り，先頭にIVを付加します

[IV][P xor RC4(S)]

ここまでで，WEPによる暗号化が完了します．

### WEPによる復号の手法

受け取った暗号文を復号化するには以下のように，暗号化と逆の操作を行います．

1. 暗号文[IV][P xor RC4(S)]から[IV]を取得します．

[IV]

2. IVと，既知であるWEPキーとを結合してSを作ります．

S = [IV][WEP]

3. このSを再びRC4に入力すると，暗号化時に使用したものと同じキーストリームが得られます．

キーストリーム　= [RC4(S)]

4. [P xor RC4(S)]とキーストリームの排他的論理和をとり，平文メッセージMとチェックサムが得られます．

P = [P xor RC4(S)] xor キーストリーム = [M][SC]

ここまでの操作で，暗号文から平文メッセージMとチェックサムSCが得られ．
WEPキーは正しかったかやエラーが発生していなかったかどうかを
チェックサムを使って確認することができます．

### どこに脆弱性があるのか

1. チェックサムと，WEPキーの長さの問題
WEPキーが，特に40ビットの場合，十分な長さを持っておらず[1]，また総当たりで鍵を探した場合に，
チェックサムにより，その鍵が正しい可能性があるのかどうかを判別できる点[2]が問題になってしまう．

2. WEPキーが固定されている．
WEPキーでは一度手動設定すると，再び手動で変更するまで同じ値を使い続けるので，

3. IVの取りうる値の範囲が小さい点, IVが平文で送られる点
WEPが使用しているIVの長さは，24ビットしかなく，同じ値のIVがほぼ確実に再利用されてしまうことが問題です[2]．
IVが同じであると，キーストリームも再利用することになり，

C1 = P1 xor RC4(S)
C2 = P2 xor RC4(S)
C1 xor C2 = (P1 xor RC4(S)) xor (P2 xor RC4(S)) = P1 xor P2

となり，一方の平文が判明した時に，もう一方の平文が簡単にわかってしまいます．
また，IVが平文で送られてくるため，どのパケットが同じIVを使用しているのかが瞬時にわかってしまうことも問題です．

### 攻撃手法
WEPに対する攻撃の中で特に有名なのがFMS攻撃です．
FMS攻撃では，IVが'弱いIV'と言われる特定の値になった時にRC4のキーストリームの偏りが激しくなり，
'弱いIV'が使われたパケットを沢山集めれば，WEPキーの予測ができてしまうことを利用しています[4]．

### 対策方法
WEPでの暗号化は,
1. WEPキーが短いこと
2. IV部分が短いこと
3. IVが平文で送られてくること
4. WEPキーが固定されていること
が主な問題となっており，現在では，使用が推奨されていません．

代わりに，改良された，WAPや，WAP2を使用すると良いです．

WAPでは，共有キーを128ビットに，IVを48ビットまで増やし，
共有キーへの総当たり攻撃をより難しくなり，またIVの衝突を減らし，キーストリームの再利用の可能性を少なくしています．
また，VIを暗号化して送ることができるようになっているので，どのパケットがIVを共有しているのかを隠すことができています．
また，一定の期間で暗号キーを更新することができるので，パケットから鍵を推測することが難しくなっています．

さらに改良されたWAP2では，暗号化アルゴリズムのRC4から，AESを採用しており，
WEP, WAPと比べて，一層暗号の強度を増しています．

### 気が付いたこと，感想

「WEPキーは脆弱」というのが，一般的に常識であるので，WEPの暗号化の仕組みを見たら，誰でもすぐに「これは脆弱だ」とわかるものだと思っていましたが，
実際に暗号化の手順を追っていくと，当初思っていたよりも厳重な暗号化処理が行われていたことに驚いた．
また，WEPの仕組みを調べるのにいっぱいになってしまい，脆弱性についての調査，実験があまりできなかったのが残念ですが，
WEPの仕組みがよく理解でき，今後につながる学習ができてよかったです．

参考文献
[1] 上原孝之, 情報処理教科書情報処理安全確保支援士 2018年度版, 昭和情報プロセス株式会社, 2017
[2] JON ERICKSON, 訳: 村上雅章 HACKING: 美しき策謀 第2版 脆弱性攻撃の理論と実際, オライリージャパン, 2014
[3] 汐崎陽, 情報・符号理論の基礎, オーム社, 2017
[4] nekopippi, WEPの鍵復元，猫だけど何か，https://nekopippi.tumblr.com/post/166952580364/wep%E3%81%AE%E9%8D%B5%E5%BE%A9%E5%85%83, 訪問日:2018/05/28






## 問6
以下にDebian 8.10（amd64）上で動作するプログラムchal00のmain関数の逆アセンブル結果があります
("objdump -d chal00"の出力結果のうち、main関数の箇所を抜粋しました)。
このプログラムは、コマンドライン引数としてある特定の文字列を指定されたときのみ実行結果が0となり、
それ以外の場合は実行結果が1となります。
この実行結果が0となる特定の文字列を探し、その文字列を得るまでに考えたことや試したこと、
使ったツール、抱いた感想等について詳細に報告してください。
```
00000000004003c0 <main>:
  4003c0:       48 b8 0f 0e 0d 0b 00    movabs $0xc0601000b0d0e0f,%rax
  4003c7:       01 06 0c
  4003ca:       83 ff 02                cmp    $0x2,%edi
  4003cd:       48 89 44 24 f0          mov    %rax,-0x10(%rsp)
  4003d2:       48 b8 04 05 08 0a 02    movabs $0x70903020a080504,%rax
  4003d9:       03 09 07
  4003dc:       48 89 44 24 f8          mov    %rax,-0x8(%rsp)
  4003e1:       b8 01 00 00 00          mov    $0x1,%eax
  4003e6:       75 59                   jne    400441 <main+0x81>
  4003e8:       48 8b 56 08             mov    0x8(%rsi),%rdx
  4003ec:       31 c0                   xor    %eax,%eax
  4003ee:       89 c1                   mov    %eax,%ecx
  4003f0:       48 ff c0                inc    %rax
  4003f3:       80 7c 02 ff 00          cmpb   $0x0,-0x1(%rdx,%rax,1)
  4003f8:       75 f4                   jne    4003ee <main+0x2e>
  4003fa:       83 f9 08                cmp    $0x8,%ecx
  4003fd:       b8 01 00 00 00          mov    $0x1,%eax
  400402:       75 3d                   jne    400441 <main+0x81>
  400404:       48 8b 32                mov    (%rdx),%rsi
  400407:       31 c0                   xor    %eax,%eax
  400409:       30 c9                   xor    %cl,%cl
  40040b:       48 89 f2                mov    %rsi,%rdx
  40040e:       48 d3 ea                shr    %cl,%rdx
  400411:       83 e2 0f                and    $0xf,%edx
  400414:       0f b6 54 14 f0          movzbl -0x10(%rsp,%rdx,1),%edx
  400419:       48 d3 e2                shl    %cl,%rdx
  40041c:       83 c1 04                add    $0x4,%ecx
  40041f:       48 09 d0                or     %rdx,%rax
  400422:       83 f9 40                cmp    $0x40,%ecx
  400425:       75 e4                   jne    40040b <main+0x4b>
  400427:       48 33 05 92 ff ff ff    xor    -0x6e(%rip),%rax        # 4003c0 <main>
  40042e:       48 ba 85 03 0e 67 b3    movabs $0x600967b3670e0385,%rdx
  400435:       67 09 60
  400438:       48 39 d0                cmp    %rdx,%rax
  40043b:       0f 95 c0                setne  %al
  40043e:       0f b6 c0                movzbl %al,%eax
  400441:       c3                      retq
```

使用したソフト: 
gcc version 7.3.0 (Debian 7.3.0-11) 
GNU gdb (Debian 7.12-6+b1) 7.12.0.20161007-git
テスト実行は
Linux kali 4.14.0-kali3-amd64 #1 SMP Debian 4.14.12-2kali1 (2018-01-08) x86_64 GNU/Linux
の環境で行いました．

基本的に静的解析を行い，動作が分かり難かったところや，静的解析の答合わせの為に
gdbを利用した動的解析を行いました．

## 問題を見た第一印象
アセンブリ言語を最近学び始めたばかりだったのですが，オペランドのレジスタの指定に%記号が使われていたのでAT&T記法で書かれたものであると推測できました．

## 逆アセンブリ結果を分割する
問題に与えられた，逆アセンブリ結果をjump命令ごとに次の[B1]〜[B5]のように分割して考えました．なぜjump命令で分割したのかというと，jump命令は，ループ文や，条件分岐などで使用されることが多く，ブロックごとに意味で分けることができるのではないかと考えたからです．

[B1]
00000000004003c0 <main>:
 から
  4003e6:       75 59                   jne    400441 <main+0x81>
 まで

[B2]
  4003e8:       48 8b 56 08             mov    0x8(%rsi),%rdx
  から
  4003f8:       75 f4                   jne    4003ee <main+0x2e>
  まで

[B3]
  4003fa:       83 f9 08                cmp    $0x8,%ecx
  から
  400402:       75 3d                   jne    400441 <main+0x81>
  まで

[B4]
  400404:       48 8b 32                mov    (%rdx),%rsi
  から
  400425:       75 e4                   jne    40040b <main+0x4b>
  まで

[B5]
  400427:       48 33 05 92 ff ff ff    xor    -0x6e(%rip),%rax # 4003c0 <main>
  から
  400441:       c3                      retq
  まで

### [B1]について
このブロックでは，
1. 0xc0601000b0d0e0fと，0x70903020a080504をスタックに格納しています．実はこれらの値の並びはリトルエンディアンになっており，[B6]の解析時に，そのことに気がつくまでかなりの時間を費やしてしまいました．

2. %ediが2出ないならば，実行結果を1にして終了
当初，%ediがなんの数字なのかが理解できませんでしたが，
Googleで検索することですぐに理解することができました．
%ediには，引数の数が格納されており，この部分では，$ 実行ファイル名  文字列
の形式で実行していないと駄目であることがわかります．
同様に，%rsiには，引数の文字列が格納されていることがわかりました．

まとめると，C言語で通常 argcとかく部分が%edi, argvと各部分が%rsiに格納されているということがわかりました．

**[B1]まとめ**
- スタックに0xc0601000b0d0e0fと0x70903020a080504を格納する
- $ 実行時刻ファイル名 文字列 のように実行しなければならない

### [B2]について
[B2]では，0x4003f8の命令
jne    4003ee <main+0x2e>
より，0x4003ee から 0x4003f8の間でループが作られていることがすぐにわかりました．

このブロックでは，
引数の文字列の長さを計算し，
その結果(引数のNullを含まない文字列の長さ)をecxに格納しています．

**[B2]まとめ**
引数の長さを計算する

### [B3]について
ecxの値，つまり，引数の文字列の長さが8以外であれば結果を1で終了しています．

**[B3]まとめ**
引数の文字が8文字でなければ失敗で終了

### [B4]について
0x400425の命令
jne    40040b <main+0x4b>
を見ることで，0x40040b から　0x400425がループ構造になっていることがすぐにわかりました．

このブロックは，プログラムの中で，一番重要な部分つまり暗号化を担っている場所でした．
このブロックの暗号化の結果はraxに格納されます．

このブロックでは以下のことを行なっています．
1. rsiに引数の文字列を代入します．
2. eax, cl を0に0を代入します．
3. rdx に rsiの文字列をコピーします．
4. rdxをclビットだけ右へ算術シフトします．
5. rdxと0xfの排他的論理和を取ることで，rdx下4ビットだけを取得します．
6. [B1]で，スタックに格納されていた
  0c　06　01　00　0b　0d　0e　0f  - 07　09　03　02　0a　08　05　04
  のうち，リトルエイディアン順でrdx番目の値を取得しrdxに代入します．
7. 変換後のrdxを左へclビットだけ左シフトすることで，値のあった場所をもとの位置に戻します．
8. ecxに0x4を加えます
9. raxに変換結果を追加します．
10. 3~9までの手順を引数の文字列一文字ずつ全てに適応します．

この手順の6.の手順で，スタック上でのrdx番目の値を取り出す時に，当初，そのままの並び(ビッグエンディアン)で並んでいると勘違いしており，結果が合わないことに非常に悩みました．

このがリトルエンディアンになっていることは，gdbによって繰り返し動的解析をして，値を目で追っていたら気がつくことができました．

教科書などでは，値がリトルエンディアンで格納されているという情報をよく見ていましたが，
ここで初めてその意味を理解することができました．

**[B3]まとめ**
1. 与えられた文字列を4ビット取り出し，スタック上に格納された値のリトルエンディアン順で(取り出された値)番目の値に置き換える．

### [B5]について
このブロックでは，(文字列の変換結果と(rip-0x6eに格納されている値)の排他的論理和)と，(正解の文字列の変換結果)が同じであるかを評価しています．同じであれば計算結果を0にして，正常終了します．

このブロックでは次のことを行なっています．
1. [B4]での変換結果と(rip-0x6eに格納されている値)の排他的論理和を計算し，raxに格納します.
2. raxと，0x600967b3670e0385を比較し，等しければ0, 異なれば1を返して終了します．

**[B5]まとめ**
変換結果と(rip-0x6eに格納されている値)の排他的論理和と，0x600967b3670e0385を比較し，等しければ0, 異なれば1を返して終了する．

## 求める文字列を逆算する

[B5]より，与えられた文字列の変換結果と，0x600967b3670e0385が等しければ良いことがわかりました．

変換は，[B4] の処理 → -0x6e(%rip) = 0x1000b0d0e0fb848との排他的論理和となっていたので，

0x600967b3670e0385が最終結果になるためには，[B4]の処理で何を出力すべきなのかを
0x1000b0d0e0fb848との排他的論理和の結果を逆算することで求めます．

>>> hex(0x600967b3670e0385 ^ 0x1000b0d0e0fb848)
'0x61096cbe6901bbcd'

より，[B4]の処理結果が0x61096cbe6901bbcdであることがわかりました．

この結果は，与えられた引数と，4ビットずつ一対一で対応しているので，
スタックに格納されている値と対応づけて，元に戻すことができます．

つまり，

引数　→ 変換値が
0 → 0F
1 → 0E
2 → 0D
3 → 0B
4 → 00
5 → 01
6 → 06
7 → 0C
8 → 04
9 → 05
A → 08
B → 0A
C → 02
D → 03
E → 09
F → 07

となっていたので，その逆の表

0 → 4
1 → 5
2 → D
3 → B
4 → 8
5 → 9
6 → 6
7 → C
8 → 4
9 → E
A → B
B → 3
C → 7
D → 2
E → 1
F → 0

を利用して，逆変換します．

0x61096cbe6901bbcd → 0x654e67316e453372

これを文字列に変換すると，
>>> for i in range(8):
...     print(chr(int(dec[i*2:i*2+2], 16)), end='')
...
eNg1nE3r

この文字列もリトルエンディアンとなっているので，
実際に入力される文字は，次のようになります．

r3En1gNe

Reengineeringのleet文字だと推測できます．

## 検証

gccで実行ファイルに変換した結果がa.outになっています．
echo $?で戻り値を表示することができます．

root@kali:~/Desktop# ./a.out r3En1gNe; echo $?
0

確かにr3En1gNeを入力すると結果が0になっていることがわかります．

## 結論

入力すべき値は　r3En1gNe


## 問7
chal01.zipには、USBメモリのディスクイメージusb_disk_modified.img が入っています。
そのイメージファイルをマウントしようとしましたが、エラーが出てマウントできませんでした。
どうやらどこかが壊れているようです。
ファイルシステムの構造を調べ、壊れていると思った全ての箇所を修正し、
マウントツール(*1)でマウントできるようにした後、
ファイルシステム上に存在するPDFファイルを救い出してください。
* (*1)マウントツールの例
    * mount (for linux)
    * hdiutil (for macos）
    * FTK Imager（for Windows）

また、以下の設問の答えとその解き方を、ファイルシステムの調査結果を用いて説明してください。
答えのみの場合は正解とはみなしません。修正箇所が複数ある場合は、全て列挙してください。

1. このイメージの元のファイルシステムの名称は？

A. NTFS

はじめに，本当にマウントできないかどうかを試しました．

$ hdiutil attach usb_disk_modified.img
hdiutil: attach failed - マウントできるファイルシステムがありません

確かにできないことがわかりました．

続いて，fileコマンドを実行しました．
$ file usb_disk_modified.img
usb_disk_modified.img: DOS/MBR boot sector

なんとなく，違和感を覚えましたが，
なんのファイルシステムが使用されているかはわかりませんでした．

次にstringsコマンドを実行しました．
すると，
以下のような文字列をつけることができました．

A disk read error occurred
BOOTMGR is compressed
Press Ctrl+Alt+Del to restart
An operating system wasn't found. Try disconnecting any drives that don't
contain an operating system.

FILE0
FILE0
FILE0
FILE0

A disk read error occurred
BOOTMGR is compressed

これらの文字列を順にGoogleで検索しました．
すると，「FILE0 filesystem」と検索したところで，
https://whereismydata.wordpress.com/2009/04/23/forensics-mft-file-and-file0/
こちらのサイトで，NTFSの名前を見つけることができました．

続いて，「NTFS 構造」と調べたところで，
https://qiita.com/kusano_k/items/45b0a86649aabb8040ff
や
http://www.ntfs.com/ntfs-partition-boot-sector.htm
のページを見つけることができました．

これらのサイトに乗っているNTFSのバイナリと手元にある問題のファイルのバイナリを見比べてみたところ，
先頭数文字の値が異なっていることに気がつきました．

試しに，他のサイトのバイナリの真似をして，てものにあるファイルをhexeditを使い，次のように書き換えてみました．

00000000  eb 52 90 00 00 00 00 20  20 20 20 00 00 00 00 00  |.R.....    .....|
↓
00000000  eb 52 90 4e 54 46 53 20  20 20 20 00 02 08 00 00  |.R.NTFS    .....|

書き換え後，再びfileコマンドを試してみると，表示される情報が増えていることがわかりました．

$ file usb_disk_modified.img
usb_disk_modified.img: DOS/MBR boot sector, code offset 0x52+2, OEM-ID "NTFS    ", sectors/cluster 8, Media descriptor 0xf8, sectors/track 63, heads 255, hidden sectors 2048, dos < 4.0 BootSector (0x0), FAT (1Y bit by descriptor); NTFS, sectors/track 63, physical drive 0x80, sectors 204799, $MFT start cluster 8533, $MFTMirror start cluster 2, bytes/RecordSegment 2^(-1*246), clusters/index block 1, serial number 02218df6618df378d

続けて，hdiutilコマンドで再びマウントを試みてみると，今度はうまくいくことができました．
$ hdiutil attach usb_disk_modified.img
/dev/disk4          	                               	/Volumes/usb_disk

NTFSと仮定して，ファイルを修正したところ，
マウントに成功することができたので，このファイルはNTFSであると推測することできます．

2. どのオフセットを何のバイト列に置き換えて直したのか？壊れていると判断した理由は？

1) 0x0 から始まる
eb 52 90 00 00 00 00 20  20 20 20 00 00 00 00 00  |.R.....    .....|を
eb 52 90 4e 54 46 53 20  20 20 20 00 02 08 00 00  |.R.NTFS    .....|に書き換えました

2) 
0x02165000から始まる
42 41 41 44 30 00 03 00  00 00 00 00 00 00 00 00  |BAAD0...........|を
46 49 4c 45 30 00 03 00  00 00 00 00 00 00 00 00  |FILE0...........|に書き換えました．

[理由]

1) は「1. このイメージの元のファイルシステムの名称は？」で記述した通り，他のサイトのバイナリと見比べたときに，
手元にあるものと値が違っていたので書き換えました．

2) hexeditでバイナリを眺めていたら，

「FILE0 → ファイル名」

の順番になっていることが多いことに気がつきました．
にも関わらず，0x02165000から始まる部分では，

「BAAD0　→ iir_vol38.pdf」となっていたので，他のものと同じになるように書き換えました．

3. そのオフセットの位置は何という名称の構造体の何というメンバがあるはずなのか？

構造体やメンバの名称はわかりませんでしたが，
http://www.kes.talktalk.net/ntfs/
を見ることで，

1) で書き換えた場所は，セクターのサイズを表し，
2) で書き換えた場所は，レコード識別子であることがわかりました．
  「BADD」はそのエントリが使用不可であることを表してます．

また，わかったこととして，

$Standard_Information
$Attribute_List
$File_Name
$Object_ID
$Security_Descriptor
$Volume_Name
$Volume_Information
$Data
$Index_Root
$Index_Allocation
$Bitmap
$Reparse_Point
$Ea_Information
$EA
$Propery_Set
$Logged_Utility_System

などの属性があり，それぞれバイナリ内での位置が決まっていることがわかりましたが，
そのような場所は触っておらず．また，また間違っている箇所を特定できませんでした．

おそらく，上に挙げたような属性を修正した時に現れるファイルがあるはずです．

4. PDFファイルのハッシュ値をすべてsha256で答えよ。

編集済みのディスクをマウントします．

$ hdiutil attach usb_disk_modified.img 
/dev/disk4

マウント先へ移動します．
$ cd /Volumes/usb_disk/

shasumコマンドによってsha256のハッシュ値を計算します．
$ shasum -a 256 iir_vol37.pdf
5d62f82532d62645cd67b312546a599d90d15ea09c5ee5dbd61c5d90fc945ad3  iir_vol37.pdf

$ shasum -a 256 iir_vol38.pdf
86eb9f1fe34087f709a659b051d4d06930078c72d420683f2bf89455f31eb55f  iir_vol38.pdf


5d62f82532d62645cd67b312546a599d90d15ea09c5ee5dbd61c5d90fc945ad3
86eb9f1fe34087f709a659b051d4d06930078c72d420683f2bf89455f31eb55f 

https://docs.google.com/forms/d/e/1FAIpQLSd_Ne6RuXusW-Z5dbJwjoilXGJWdt3JygbENc27YD93mHl0Ow/viewform?usp=form_confirm&edit2=2_ABaOnudM5l_2oJMrllggnD--ss2_rfuAGbxbYasUcQ0Y9DetlHchEyzBQKuek9A
